.NET Core Dependency Injection
==============================

## Intro

Hi, in this video I'm going to showcase the Microsoft .NET Core Dependency Injection abstractions and how other frameworks like ASP.NET Core use them internally.


### Registration and Resolution

For the basics, there are two main interfaces, which correspond to the two main phases for dependency injection.

In this code sample, I have defined a class and an interface. As in most dependency injection frameworks, we have two phases:
Registration and resolution.

In the .NET Core DI system, we use a so-called ServiceCollection to register our objects.

From the ServiceCollection, we can build a ServiceProvider. The service provider is able to resolve all the services, that have been registered to the afore-mentioned service collection that was used to create the ServiceProvider.

In a lot of other frameworks, there is less of a separation between Registration and Resolution.
This design of the interfaces forces developers to initialize the entire dependency graph at the initialization of an application, which makes debugging problems with the dependency injection much easier.

When we run out sample, we can see that we can sucessfully register our service, and resolve it from the ServiceProvider.
If we were to register our service after the creation of our service provider, the provider will not know about the existance of the service and will therefor not be able to resolve it.

### Service Lifetimes

Let's take a look at service lifetimes next.

I've extended the previous example with some additional code that will help us visualize the differences for lifetimes.
Whenever a new service is created, it will generate a unique ID for it's instance.

After we resolve our service, we can print the instance ID to see, if a new instance was created during the resolution of the service.
When we register the service as transient, we can observe, that every time we resolve the service, a new instance of the service is constructed.
If we register the service as scoped or singleton, we get the same instance everytime.

So during the registration, we control how long a service will stick around. Although currently, we only have the option between new instance everytime, and same instance for the entire duration of our provider.

### Service scopes

That's where the service scope comes in.

When resolving our scoped service, the service provider initializes it the so-called root-scope of the container.
However, we can create a custom service scope using an IServiceScope created by the .CreateScope method on the ServiceProvider.

The IServiceScope has contains a separate reference to the ServiceProvider, which will instantiate scoped services as part of it's scope.
If we resolve a scoped service multiple times inside the scope, we get the same instance everytime. If we resolve the service in a separate scope however, we will also receive a also receive a separate instance.

Now there is also the time to explain the optional parameter for the BuildServiceProvider method.
It's possible to enable so-called scope validation. With scope validation enabled, the service provider will not allow the resolution of scoped services on the root scope.

As a side-note: This is enabled for development environments in ASP.NET Core as well, which is why you have to create your own ServiceScope, when you are trying to use scoped services, like Entity Framework Contexts as part of the app start, when no request is currently being processed. Apart from AppStart, where you might want to seed your database and run migrations, you don't usually need to do this, as ASP.NET Core itself creates a service scope for each request that is being processed.

As a summary, transient services are constructed for every resolution.
scoped services behave like singletons inside their own scope.
singleton services are created only once, even across different scopes.

